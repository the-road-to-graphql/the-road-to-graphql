# Introduction

State management in applications has become a popular topic in the recent years. Single page applications (SPAs) - that are only delivered once from a web server yet stay interactive - have to establish state management in the frontend. They have to keep the state consistent without making any more requests to the backend. They have to give the user an effortless and pleasant experience when using the application. It already starts when opening a popup in your application. Someone has to be aware of this state. But who manages this state?

jQuery was a popular library before the first SPA solutions, such as Angular, Ember, and Backbone appeared. State management itself wasn't a huge problem in jQuery in the beginning, because the library was most often only used for selective DOM manipulations. You could add animations to your HTML, add or remove DOM nodes or change the style of your HTML programatically.

Eventually, the jQuery code, and in general the portion of JavaScript code compared to HTML and CSS grew, and people wrote more sophisticated frontend applications. Most of the time, it ended up in a mess of jQuery code where not only state management was a problem, but also general best practices like clean code were missing. There was no solution for the general architecture of these kind of frontend applications and people struggled to keep it maintainable in larger applications.

After a while, single page application (SPA) solutions like Angular, Ember and Backbone emerged to give these unstructured frontend applications a proper framework around them. The greater part of the SPAs build up on the model-view-controller (MVC) pattern to architect the application. These frameworks contain everything you would need, from a view layer for displaying HTML in the browser to a model layer for interacting with your backend, to build your sophisticated application. The term SPA was coined, because these applications are only served once from the backend, as a single page, but then operate only in the frontend. They are blobs of HTML with JavaScript which contain everything the applications needs to work on the client-side. When navigating to a different page under a different URL, there is no reloading required. They only interact with the backend to pull or push new data from or to it. Thus, the only thing that changes is the state inside the application. But who manages this state?

Even though these solutions established best practices, patterns and architectures for the first generation of SPAs, state management became a recurring issue. When interacting with the backend to retrieve new data, it was unclear how to manage the data in a predictable way. When triggering view related elements, such as modals or popups, in the frontend, often there wasn't established best practice to manage these states. Every framework tried to apply their own solution for it. Eventually, people came up with their own best practices and libraries, but it never became a predictable and consistent experience to manage state with clear constraints.

There was one major flaw with these SPA solutions that led to this problem in the first place: As frameworks, they tried to solve too many issues at once. They wouldn't have the chance to solve all issues in the first generation of their existence in the world of SPAs. Eventually, they solved these issues in a future iteration when other SPA solutions appeared at the scene.

The second generation of SPA solutions, among them libraries like React and Vue, focused only on smaller parts of the application. They focused on the view layer. It was up to the engineer to decide on further libraries as solutions for specific problems. [That's what made React such a powerful library in the first place](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/), because everyone could decide to extend the application with libraries that solve specific yet small problems.

Nowadays, a ton of articles and libraries try to solve the issue of state management. It is difficult to find a consistent source of truth to learn state management in modern applications. Even though, solutions like React have their own state management implementation for local state in components, there are more external solutions coming as libraries such as Redux and MobX that establish sophisticated state management.

Still, it lacks one guide to navigate through all these different solutions to make the differences and benefits clear. Quite often, the guides miss the point of teaching the problem first. In addition, instead of showing the minimal approach, they try to fix the problem of state management by using over-engineered approaches. But it can be so much simpler. It only needs one resource to guide through state management in modern applications in a consistent and constructive way. That's the mission of this book.

If you want to learn something, you have to do it step by step. Trying to solve each atomic problem after the next one. Don't apply everything at once. Understand the problem and solve it. That's my attempt with this book: It doesn't only teach Redux in React, but state management in modern applications. It goes beyond the documentation of state management libraries, but applies the learnings in real world applications in the book.

These are the heroes of the book: Local State (in React), Redux and MobX. It wouldn't have been possible to write the book without the innovators behind these solutions: [Dan Abramov](https://twitter.com/dan_abramov), [Andrew Clark](https://twitter.com/acdlite) and [Michel Weststrate](https://twitter.com/mweststrate). I guess, I can thank them in the name of the community for their efforts to make state management in modern applications a consistent and enjoyable experience.